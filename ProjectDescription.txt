I. General description, configuration of solution:

	By default solution configured for evaluating spreadsheet with expressions that contains:

	1. Integers operators +, -, *, /, ^ (exponentiation), according to it`s priority.
	Set of operators or it`s priority could be changed by creating OperatorManager or modifying configuring default one.
	String operators also could be easily added there, for example:
		new Operator<string>('&', 1, (l, r) => l + r)

	2. Parenthesis for changing operation priority. If it`s needed to disable them, corresponding constants should be replaced with some unused characters in SpesialCharactersSettings 

	3. Spreadsheet evaluation could be customizing by passing processing strategy to SpreadsheetProcessor, currently exists:
		- SimpleProcessingStrategy - processing done in one thread.
		- ParallelProcessingStrategy - parallel multythread processing using TPL.

II. Strange part in the project:

	1. Manual integer done to get integers while reading input stream char by char 
	without creation of redundant string to pass in to standard function int.Parse.

	2. Class ExtendedLazy is slightly modified version of standard Lazy class (https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Lazy.cs). 
	Lazy uses parameterless delegate for object initialization, ExtendedLazy receive constructor delegate with parameter and parameter it self. 
	Those changes helps to prevent closure of cell variable and creation of extra types for holding closure variable, as it`s displayed in this example:
	http://tryroslyn.azurewebsites.net/#K4Zwlgdg5gBAygTxAFwKYFsDcAoADsAIwBswBjGUogQxBBgGEYBvbGN919/YsmANwD2YACYwAsgAoAlDE5sW7RTEjJ+VIjAC8MAIyZZS9nyoAnGKu0RUAdxgAZKgC8EAHgEEAVqlLIAfBOktXzUNAGoYAGYpHEUAX2xYoAAA

	3. Classes PooledHashSet and it`s base class ObjectPool copied from Roslyn source code (http://source.roslyn.codeplex.com/#Microsoft.CodeAnalysis/PooledHashSet.cs) for reusing HashSet`s during deadlock checking.   

III. Possible problems:
	
	1. Spreadsheet size limitation
	Spreadsheet stored in array so size more than couple hungered millions cells could case OutOfMemoryException. 
	Problem could be solved by changing way of storage in Spreadsheet class and also cash storage inside SpreadsheetProcessor. 

	2. Integer size limitation
	Integers in expressions have standard limitations for signed 32 bit`s numbers. 
	So if bigger numbers required long should be used or even BigInt, but it will increase memory usage.

	3. Boxing of value types
	All expression stored and processed as objects so value types will be boxed during evaluation, which results in creation a lot of redundant objects.

	4. Double memory usage
	Beside of storing spreadsheet in memory SpreadsheetProcessor also store evaluated values, 
	which results in more memory usage, but prevents evaluation of cell value couple times.

	6. Reading slower that calculation
	Reading of expression takes more time than it`s evaluation.

	7. Multithreading slow down calculation for simple expressions
	On a spreadsheet with simple expressions more recourses spend for synchronizing multiple threads than gained from splitting execution between threads.

IV. Ways to optimize solution:
	
	1. Start calculation during reading
	As it was sad before reading of spreadsheet takes much more time evaluating of it. 
	Possible way to speed up solution is starting cell value evaluation, just after it was read.
	This could give speed improvement for spreadsheets where cells mostly referenced to cells that were read before.

	2. Expression cashing
	Large amount of memory used for storing expressions could be reduced by using expression cashing similar to how it`s done in Roslyn:
	https://github.com/dotnet/roslyn/blob/1c74e1b4698881d87870cf53fef06549ea348763/src/Compilers/CSharp/Portable/Syntax/InternalSyntax/SyntaxNodeCache.cs
	https://roslyn.codeplex.com/discussions/541953
		
	3. Expression simplification
	If memory used for storing spreadsheet needs to be reduced, and there is no need in displaying spreadsheet how it is, expressions can be reduced during parsing or after it.
	For example if binary expression has only constant values it could be replaced with constant, and one object will be stored instead of three.